Archivo 1,Archivo 2,Texto llano (DiffUtil),Tokenizado (DiffUtil),Coincidencias Diff (TP),Coincidencias Diff (TK)
dataset/1531746.py,dataset/1679741.py,6.71%,2.22%,score = 0 for,
dataset/1012763.py,dataset/1012765.py,8.70%,3.49%,"print(solve(xs, ys, xt, yt, N, a))",
dataset/1308327.py,dataset/1308139.py,55.64%,52.73%,"import math Y, X, K = map(int, input().split()) a = [[0 if c==""x"" else 1 for c in input()]for i in range(Y)] | for x in range(X): fr = 0 for y in range(Y + 1): if y == Y or a[y][x] == 0: for i in range(math.ceil((y - fr) / 2)): a[fr+i][x] = i+1 a[y-i-1][x] = i+1 fr = y + 1 | = (K-1)*2 + 1 | for y in range(K-1, Y-K+1): | = 0 cnt = a[y].count(0) for i in range(cnt+1): | if i < cnt else X-1","import ID_1 ID_2 , ID_3 , ID_4 = ID_5 ( ID_6 , ID_7 ( ) . ID_8 ( ) ) ID_9 = [ [ CONST if ID_10 == CONST else CONST for ID_10 in ID_7 ( ) ] for ID_11 in ID_12 ( ID_2 ) ] for ID_13 in ID_12 ( ID_3 ) : ID_14 = CONST for ID_15 in ID_12 ( ID_2 + CONST ) : if ID_15 == ID_2 or ID_9 [ ID_15 ] [ ID_13 ] == CONST : for ID_11 in ID_12 ( ID_1 . ID_16 ( ( ID_15 - ID_14 ) / CONST ) ) : ID_9 [ ID_14 + ID_11 ] [ ID_13 ] = ID_11 + CONST ID_9 [ ID_15 - ID_11 - CONST ] [ ID_13 ] = ID_11 + CONST ID_14 = ID_15 + CONST ID_17 = CONST ID_18 = | ( ID_4 - CONST ) * CONST + CONST | ID_21 = ID_9 [ ID_15 ] . ID_22 ( CONST | = CONST break elif | : ID_17 += CONST"
dataset/1021922.py,dataset/1021919.py,96.18%,23.73%,"#!/usr/bin/python import sets import sys def find(parent, x): if parent[x] == x: return x else: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, x, y): | def main(argv): tokens = sys.stdin.readline().rstrip(""\n"").split() while len(tokens) == 3: n, k, l = [int(i) for i in tokens] parent_roads = [int(i) for i in xrange(n)] parent_railways = [int(i) for i in xrange(n)] for i in xrange(k): x, y = [int(i) for i in raw_input().split("" "")] union(parent_roads, x - 1, y - 1) for i in xrange(l): x, y = [int(i) for i in raw_input().split("" "")] union(parent_railways, x - 1, y - 1) count = dict() for i in xrange(n): key = (find(parent_roads, i), find(parent_railways, i)) if not count.has_key(key): count[key] = 0 count[key] += 1 results = [] for i in xrange(n): key = (find(parent_roads, i), find(parent_railways, i)) results.append(str(count[key])) print "" "".join(results) tokens = sys.stdin.readline().rstrip(""\n"").split() if __name__ == ""__main__"": main(sys.argv)","import ID_1 import ID_2 def ID_3 ( ID_4 , ID_5 ) : if ID_4 [ ID_5 ] == ID_5 : return ID_5 else : ID_4 [ ID_5 ] = ID_3 ( ID_4 , ID_4 [ ID_5 ] ) return ID_4 [ ID_5 ] def ID_6 ( ID_4 , ID_5 , ID_7 ) : | ID_3 ( ID_4 , ID_7 ) if | ) == CONST : | ) ) if not"
dataset/1478030.py,dataset/1478027.py,96.11%,10.09%,"EMPTY = 0 BLACK = 1 WHITE = 2 N = input() G = {i: [] for i in range(1, N+1)} for i in range(N-1): a, b = map(int, raw_input().split()) G[a].append(b) G[b].append(a) parent = {} dist = [N] * (N+1) dist[1] = 0 que = | while len(que) > 0: s = | for t in G[s]: if dist[t] > dist[s]+1: dist[t] = dist[s]+1 parent[t] = s que.append(t) s = N path = [s] while s in parent: path.append(parent[s]) s = parent[s] path = path[::-1] colors = [EMPTY] * (N+1) n = len(path) que_black, que_white = | for i in range(n): if i % 2 == 0: v = path[i/2] colors[v] = BLACK que_black.append(v) else: v = path[n-i/2-1] colors[v] = WHITE que_white.append(v) def paint(que, c): while len(que) > 0: s = | for t in G[s]: if colors[t] == EMPTY: colors[t] = c que.append(t) paint(que_black, BLACK) paint(que_white, WHITE) score = 0 for c in colors: if c == BLACK: score += 1 elif c == WHITE: score -= 1 print ""Fennec"" if score > 0 else ""Snuke""",ID_3 = CONST ID_4 = | > CONST else CONST
dataset/1357280.py,dataset/1357277.py,93.19%,80.94%,"def solve1(): maxx = maxy = 0 minx = miny = 1000111000 for i in xrange(n): maxx = max(maxx, x[i]) minx = min(minx, x[i]) maxy = max(maxy, y[i]) miny = min(miny, y[i]) return (maxx-minx)*(maxy-miny) def solve2a(minx): miny = min(x) maxy = max(y) maxx = 0 for i in xrange(n): if y[i] < minx: return 2**60 if minx <= x[i]: maxx = max(maxx, x[i]) else: maxx = max(maxx, y[i]) return (maxx-minx)*(maxy-miny) def solve2_(): res = 2**60 for minx in x: res = min(res, solve2a(minx)) for minx in y: res = min(res, solve2a(minx)) return res def solve2(): res = 2**60 xy = x+y xy.sort() miny = min(x) maxy = max(y) my = min(y) | pi = 0 for minx in xy: if my < minx: break while pi < n and p[pi][0] < minx: pi += 1 maxx = max(ly[pi], | res = min(res, (maxx-minx)*(maxy-miny)) return res n = int(raw_input()) x = [0]*n y = [0]*n p = [(0,0)]*n mini = maxi = 0 for i in xrange(n): x[i],y[i] = map(int, raw_input().split()) x[i],y[i] = min(x[i],y[i]),max(x[i],y[i]) p[i] = x[i],y[i] if x[i] < x[mini]: mini = i if y[maxi] < y[i]: maxi = i p.sort() ly = [0]*(n+2) | my = 0 for i in xrange(n): my = max(my, p[i][1]) ly[i+1] = my | ans = solve1() if mini != maxi: ans = min(ans, solve2()) print ans","def ID_1 ( ) : ID_2 = ID_3 = CONST ID_4 = ID_5 = CONST for ID_6 in ID_7 ( ID_8 ) : ID_2 = ID_9 ( ID_2 , ID_10 [ ID_6 ] ) ID_4 = ID_11 ( ID_4 , ID_10 [ ID_6 ] ) ID_3 = ID_9 ( ID_3 , ID_12 [ ID_6 ] ) ID_5 = ID_11 ( ID_5 , ID_12 [ ID_6 ] ) return ( ID_2 - ID_4 ) * ( ID_3 - ID_5 ) def ID_13 ( ID_4 ) : ID_5 = ID_11 ( ID_10 ) ID_3 = ID_9 ( ID_12 ) ID_2 = CONST for ID_6 in ID_7 ( ID_8 ) : if ID_12 [ ID_6 ] < ID_4 : return CONST ** CONST if ID_4 <= ID_10 [ ID_6 ] : ID_2 = ID_9 ( ID_2 , ID_10 [ ID_6 ] ) else : ID_2 = ID_9 ( ID_2 , ID_12 [ ID_6 ] ) return ( ID_2 - ID_4 ) * ( ID_3 - ID_5 ) def ID_14 ( ) : ID_15 = CONST ** CONST for ID_4 in ID_10 : ID_15 = ID_11 ( ID_15 , ID_13 ( ID_4 ) ) for ID_4 in ID_12 : ID_15 = ID_11 ( ID_15 , ID_13 ( ID_4 ) ) return ID_15 def ID_16 ( ) : ID_15 = CONST ** CONST ID_17 = ID_10 + ID_12 ID_17 . ID_18 ( ) ID_5 = ID_11 ( ID_10 ) ID_3 = ID_9 ( ID_12 ) ID_19 = ID_11 ( ID_12 ) ID_20 = | CONST for ID_4 in ID_17 : if ID_19 < ID_4 : break while | = [ ( CONST , CONST ) ] * ID_8 ID_26 = ID_27 = CONST for ID_6 in ID_7 ( ID_8 ) : ID_10 [ ID_6 ] , ID_12 [ ID_6 ] = ID_28 ( ID_24 , ID_25 ( ) . ID_29 ( ) ) ID_10 [ ID_6 ] , ID_12 [ ID_6 ] = ID_11 ( ID_10 [ ID_6 ] , ID_12 [ ID_6 ] ) , ID_9 ( ID_10 [ ID_6 ] , ID_12 [ ID_6 ] ) | [ ID_6 ] = ID_10 [ ID_6 ] , ID_12 [ ID_6 ] if ID_10 [ ID_6 ] < ID_10 [ ID_26 ] : ID_26 = ID_6 if ID_12 [ ID_27 ] < ID_12 [ ID_6 ] : ID_27 = ID_6 | . ID_18 ( ) | ID_23 = [ CONST ] * ( ID_8 + CONST ) | ID_19 = CONST for ID_6 in ID_7 ( ID_8 ) : ID_19 = ID_9 ( ID_19 , | ] [ CONST ] ) ID_23 [ ID_6 + CONST ] = | = ID_1 ( ) if ID_26 != ID_27 : | , ID_16 ( ) )"
dataset/1534024.py,dataset/1474762.py,53.56%,13.21%,from collections import defaultdict import heapq as hq | q = child_L[n] del child_L[n] hq.heapify(q) i = 0 while q: t = hq.heappop(q) if i < t: break else: i += | child_L[m].append(i) D[m] -= 1 if D[m] == 0: S.append(m) | # cycle check try: start = D.index(1) except ValueError: print('POSSIBLE') exit() | = helper(start) G = [] n = P[start] while n != start: G.append(helper(n)) n = P[n] | # 可能な初期値をそれぞれシミュレート # 1 n = s1 for g in G: if g[0] == n: n = g[1] else: n = g[0] if n != s1: print('POSSIBLE') exit() # 2 n = s2 for g in G: if g[0] == n: n = g[1] else: n = g[0] if n == s1: print('POSSIBLE') exit() print('IMPOSSIBLE'),from ID_1 import ID_2 import ID_3 as ID_4 | : break else : | : break else : | : break else : | [ CONST ] else :
dataset/1604158.py,dataset/1601396.py,18.63%,7.71%,,ID_4 = ID_5 ( ID_6 ( | ] if ID_21 (
dataset/1272054.py,dataset/1155981.py,1.45%,1.09%,,
dataset/1160494.py,dataset/1479692.py,2.68%,4.45%,,"( ) ) def | ID_8 , ID_9 ) :"
